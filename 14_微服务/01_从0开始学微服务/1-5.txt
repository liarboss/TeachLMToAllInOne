01 | 什么是微服务

1）单体应用
lamp、mvc
2）单体应用缺点
部署效率低下、团队协作开发成本高、系统高可用性差、线上发布变慢
3）什么是微服务
服务拆分粒度更细、服务独立部署、服务独立维护、服务治理能力要求高
4）敏捷开发、持续交付、DevOps理论?
敏捷开发：把一个大项目分为多个相互联系，但也可独立运行的小项目，并分别完成，在此过程中软件一直处于可使用状态。
持续交付：（英语：Continuous delivery，缩写为 CD），是一种软件工程手法，让软件产品的产出过程在一个短周期内完成，以保证软件可以稳定、持续的保持在随时可以发布的状况。
DevOps：它是一种重视“软件开发人员（Dev）”和“IT运维技术人员（Ops）”之间沟通合作的文化、运动或惯例。透过自动化“软件交付”和“架构变更”的流程，来使得构建、测试、发布软件能够更加地快捷、频繁和可靠。
它的出现是由于软件行业日益清晰地认识到：为了按时交付软件产品和服务，开发和运维工作必须紧密合作。


02 | 从单体应用走向服务化

1）什么时候进行服务化拆分
一旦单体应用同时进行开发的人员超过10人，就会遇到上面的问题，这个时候就该考虑进行服务化拆分了
2）服务化拆分的两种姿势
横向拆分：是从公共且独立功能维度拆分。
纵向拆分：是从业务维度进行拆分。
3）单体->微服务
服务如何定义：答案就是接口，无论采用哪种通讯协议，是HTTP还是RPC，服务之间的调用都通过接口描述来约定，约定内容包括接口名、接口参数以及接口返回值。
服务如何发布和订阅：注册中心
服务如何监控：通常对于一个服务，我们最关心的是QPS（调用量）、AvgTime（平均耗时）以及P999（99.9%的请求性能在多少毫秒以内）这些指标。这时候你就需要一种通用的监控方案，能够覆盖业务埋点、数据收集、数据处理，最后到数据展示的全链路功能。
服务如何治理：这就是熔断，也是服务治理最常用的手段之一。
故障如何定位：你需要有一种解决方案能够将一次用户请求进行标记，并在多个依赖的服务系统中继续传递，以便串联所有路径，从而进行故障定位


03 | 初探微服务架构
1）微服务的基本组件
    服务描述
    注册中心
    服务框架
    服务监控
    服务追踪
    服务治理

2）服务描述
    常用的服务描述方式包括RESTful API、XML配置以及IDL文件三种。

3）注册中心
    服务提供者在启动时，根据服务发布文件中配置的发布信息向注册中心注册自己的服务。
    服务消费者在启动时，根据消费者配置文件中配置的服务信息向注册中心订阅自己所需要的服务。
    注册中心返回服务提供者地址列表给服务消费者。
    当服务提供者发生变化，比如有节点新增或者销毁，注册中心将变更通知给服务消费者。

4）服务框架
    服务通信采用什么协议？就是说服务提供者和服务消费者之间以什么样的协议进行网络通信，是采用四层TCP、UDP协议，还是采用七层HTTP协议，还是采用其他协议？
    数据传输采用什么方式？就是说服务提供者和服务消费者之间的数据传输采用哪种方式，是同步还是异步，是在单连接上传输，还是多路复用。
    数据压缩采用什么格式？通常数据传输都会对数据进行压缩，来减少网络传输的数据量，从而减少带宽消耗和网络传输时间，比如常见的JSON序列化、Java对象序列化以及Protobuf序列化等。

5）服务监控
    指标收集。就是要把每一次服务调用的请求耗时以及成功与否收集起来，并上传到集中的数据处理中心。
    数据处理。有了每次调用的请求耗时以及成功与否等信息，就可以计算每秒服务请求量、平均耗时以及成功率等指标。
    数据展示。数据收集起来，经过处理之后，还需要以友好的方式对外展示，才能发挥价值。通常都是将数据展示在Dashboard面板上，并且每隔10s等间隔自动刷新，用作业务监控和报警等。

6）服务追踪
    服务消费者发起调用前，会在本地按照一定的规则生成一个requestid，发起调用时，将requestid当作请求参数的一部分，传递给服务提供者。
    服务提供者接收到请求后，记录下这次请求的requestid，然后处理请求。如果服务提供者继续请求其他服务，会在本地再生成一个自己的requestid，然后把这两个requestid都当作请求参数继续往下传递。

7）服务治理
    单机故障。通常遇到单机故障，都是靠运维发现并重启服务或者从线上摘除故障节点。然而集群的规模越大，越是容易遇到单机故障，在机器规模超过一百台以上时，靠传统的人肉运维显然难以应对。而服务治理可以通过一定的策略，自动摘除故障节点，不需要人为干预，就能保证单机故障不会影响业务。
    单IDC故障。你应该经常听说某某App，因为施工挖断光缆导致大批量用户无法使用的严重故障。而服务治理可以通过自动切换故障IDC的流量到其他正常IDC，可以避免因为单IDC故障引起的大批量业务受影响。
    依赖服务不可用。比如你的服务依赖依赖了另一个服务，当另一个服务出现问题时，会拖慢甚至拖垮你的服务。而服务治理可以通过熔断，在依赖服务异常的情况下，一段时期内停止发起调用而直接返回。这样一方面保证了服务消费者能够不被拖垮，另一方面也给服务提供者减少压力，使其能够尽快恢复。

04 | 如何发布和引用服务？

1）常见的服务发布和引用的方式有三种
RESTful API：主要被用作HTTP或者HTTPS协议的接口定义，即使在非微服务架构体系下，也被广泛采用。
XML配置
    服务提供者定义接口，并实现接口。
    服务提供者进程启动时，通过加载server.xml配置文件将接口暴露出去。
    服务消费者进程启动时，通过加载client.xml配置文件来引入要调用的接口。
IDL文件
    也就是说IDL主要是用作跨语言平台的服务之间的调用，有两种最常用的IDL：一个是Facebook开源的Thrift协议，另一个是Google开源的gRPC协议。


05 | 如何注册和发现服务？
1）注册中心三种角色
服务提供者（RPC Server）、服务消费者（RPC Client）和服务注册中心（Registry）

2）注册中心实现方式-注册中心API
    根据注册中心原理的描述，注册中心必须提供以下最基本的API，例如：

    服务注册接口：服务提供者通过调用服务注册接口来完成服务注册。
    服务反注册接口：服务提供者通过调用服务反注册接口来完成服务注销。
    心跳汇报接口：服务提供者通过调用心跳汇报接口完成节点存活状态上报。
    服务订阅接口：服务消费者通过调用服务订阅接口完成服务订阅，获取可用的服务提供者节点列表。
    服务变更查询接口：服务消费者通过调用服务变更查询接口，获取最新的可用服务节点列表。
    除此之外，为了便于管理，注册中心还必须提供一些后台管理的API，例如：

    服务查询接口：查询注册中心当前注册了哪些服务信息。
    服务修改接口：修改注册中心中某一服务的信息。

3）注册中心实现方式-集群部署
    每个Server在内存中存储了一份数据，Client的读请求可以请求任意一个Server。
    ZooKeeper启动时，将从实例中选举一个leader（Paxos协议）。
    Leader负责处理数据更新等操作（ZAB协议）。
    一个更新操作成功，当且仅当大多数Server在内存中成功修改 。

4）注册中心实现方式-目录存储
    每个目录在ZooKeeper中叫作znode，并且其有一个唯一的路径标识。
    znode可以包含数据和子znode。
    znode中的数据可以有多个版本，比如某一个znode下存有多个数据版本，那么查询这个路径下的数据需带上版本信息。

5）注册中心实现方式-服务健康状态检测
    注册中心除了要支持最基本的服务注册和服务订阅功能以外，还必须具备对服务提供者节点的健康状态检测功能，这样才能保证注册中心里保存的服务节点都是可用的。

6）注册中心实现方式-服务状态变更通知
    一旦注册中心探测到有服务提供者节点新加入或者被剔除，就必须立刻通知所有订阅该服务的服务消费者，刷新本地缓存的服务节点信息，确保服务调用不会请求不可用的服务提供者节点。

7）注册中心实现方式-白名单机制
    注册中心需要提供一个保护机制，你可以把注册中心想象成一个带有门禁的房间，只有拥有门禁卡的RPC Server才能进入。






