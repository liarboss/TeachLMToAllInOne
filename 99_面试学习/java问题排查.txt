1. 线上问题处理流程
--. 快速止损(回滚，降级，重启)，保留现场，定位问题(时间线，监控，诊断工具)，解决问题，改进措施(流程制度，系统架构)

2. 问题排查
-- 知识：日志排查，代码解决
-- 工具：工具解决问题
-- 数据：通过产生的数据查看线索

3. 知识
-- 语言：jvm，多线程知识
-- 框架：spring
-- 组件：mysql，kafka
-- 其他：网络，操作系统

java对象，申请到回收的流程
新对象->年轻代能否放下---->分配空间
        年轻代放不下---->ygc---->年轻代放的下--->分配空间
                                年轻代放不下(超大对象)--->年老代放得下--->分配内存
                                                        年老代放不下--->fgc----年老代放得下--->分配内存
                                                                              年老代放不下--->oom
旧对象-->s1/s2放的下--->增加年龄--->超过年龄阈值--->提升至old
        s1/s2放不---->提升至old

垃圾回收器
serial  年轻代   串行  复制
serial-old  年老代   串行 标记压缩
parnew   年轻代   并行  复制
cms    年老代   并行   标记清除  低停顿
parallel   年轻代  并行  复制   不可与cms共同使用
parallel old  年老代  并行  标记压缩  吞吐量
g1    都有   并行   标记-压缩，复制

吞吐量=单位时间内处理的请求数量=运行代码时间 / (运行代码时间 + 垃圾回收时间)
为什么要分代收集？— 关键字：效率
对象什么时候进入老年代？— 关键字：年龄、大小
Young GC 与 Full GC 什么时候发生？— 关键字：Eden 不足、Old 不足、Meta 不足、map/System.gc

问题1：young gc频繁触发，耗时高，如何优化？
-- 年轻代不足->增加年轻代->观察ygc次数和每次时间

4. 工具
jdk自带： jstat、jstack、jmap、jconsole、jvisualvm
开源：大名鼎鼎的Arthas、bistoury（去哪网开源）、Async-profiler

5. 数据
监控数据，如APM(应用性能管理)、metric、JVM监控、分布式链路追踪等等数据
程序运行数据：如业务数据、AccessLog、GC log、系统日志等

6. 经验
执行异常：查看日志、debug、请求重放
应用僵死：jstack
耗时高：trace跟踪、Benchmark
Cpu利用率高：Cpu profile分析
GC频繁、耗时高：GC log分析
OOM、内存占用高、泄漏：dump内存分析

七、案例分享
Cobar僵死，进程端口在，但不能处理请求
先踢掉故障机器，保留现场再排查问题，根据日志，定位为内存泄漏  java heap space
dump内存，本地分析












